<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visor/Editor de Partidas (Online)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>   

    <style>
        canvas {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            background-color: #1f2937; /* bg-gray-800 */
            cursor: grab;
        }
        #sidebar {
            position: sticky;
            top: 0;
            max-height: 100vh;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 font-sans">

    <div class="flex">
        <aside id="sidebar" class="w-80 md:w-96 p-4 bg-gray-900 border-r border-gray-700 overflow-y-auto flex-shrink-0">
            <h1 class="text-2xl font-bold text-cyan-400 mb-4">Visor de Partidas</h1>
            
            <div>
                <label for="file-input" class="block mb-2 text-sm font-medium text-gray-300">Cargar partida local (.json)</label>
                <input type="file" id="file-input" accept=".json,application/json" class="block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-700 cursor-pointer">
            </div>

            <div id="cloud-panel" class="mt-6">
                <h2 class="text-lg font-semibold text-cyan-400 mb-2">Cargar desde la Nube</h2>
                <div class="bg-gray-800 p-3 rounded-md space-y-2">
                    <div>
                        <label for="firebase-config-input" class="block mb-1 text-sm font-medium text-gray-400">Pegar `firebaseConfig`</label>
                        <textarea id="firebase-config-input" rows="3" class="w-full p-2 bg-gray-900 rounded-md text-sm text-gray-300" placeholder="{ apiKey: ... }"></textarea>
                    </div>
                    <div>
                        <label for="firebase-profile-name" class="block mb-1 text-sm font-medium text-gray-400">Nombre de Perfil (Opcional)</label>
                        <input type="text" id="firebase-profile-name" class="w-full p-2 bg-gray-900 rounded-md text-sm text-gray-300" placeholder="Ej: Paco (para stats y pos.)">
                    </div>
                    <button id="firebase-load-btn" class="w-full bg-cyan-600 text-white rounded-md text-sm font-medium hover:bg-cyan-700 px-3 py-2">
                        Cargar Mapa de Firebase
                    </button>
                    <div id="firebase-message-panel" class="text-sm text-gray-400">Introduce tu config para conectar.</div>
                </div>
            </div>

            <!-- ¡NUEVO! Filtro de Nivel Z -->
            <div id="z-level-panel" class="mt-6">
                <h2 class="text-lg font-semibold text-cyan-400 mb-2">Nivel Z</h2>
                <div class="flex space-x-2">
                    <button id="z-level-down" class="flex-1 bg-gray-700 text-white rounded-md text-sm font-medium hover:bg-gray-600 px-3 py-2">-</button>
                    <input type="number" id="z-level-input" value="0" class="w-16 p-2 text-center bg-gray-900 rounded-md text-sm text-gray-300">
                    <button id="z-level-up" class="flex-1 bg-gray-700 text-white rounded-md text-sm font-medium hover:bg-gray-600 px-3 py-2">+</button>
                </div>
            </div>

            <div id="stats-panel" class="mt-6 hidden">
                <h2 class="text-lg font-semibold text-cyan-400 mb-2">Estado del Jugador</h2>
                <div id="stats-content" class="text-sm space-y-1 bg-gray-800 p-3 rounded-md">
                    </div>
            </div>

            <div id="legend-panel" class="mt-6">
                <h2 class="text-lg font-semibold text-cyan-400 mb-2">Leyenda</h2>
                <div id="legend-content" class="grid grid-cols-2 gap-2 text-sm">
                    </div>
            </div>

            <div id="editor-panel" class="mt-6 hidden">
                <h2 class="text-lg font-semibold text-cyan-400 mb-2">Editor de Tile</h2>
                <div class="bg-gray-800 p-3 rounded-md space-y-2">
                    <p id="selected-tile-info" class="text-sm text-gray-400">Haz clic en un tile del mapa para editar...</p>
                    <select id="tile-type-select" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-md block w-full p-2.5">
                        </select>
                    <button id="download-button" class="w-full bg-green-600 text-white rounded-md text-sm font-medium hover:bg-green-700 px-3 py-2">
                        Descargar Partida Editada
                    </button>
                </div>
            </div>
        </aside>

        <main class="flex-1 h-screen overflow-auto" id="main-content">
            <div id="map-container" class="w-full h-full p-4">
                <canvas id="map-canvas"></canvas>
                <p id="loading-message" class="text-gray-400 text-center p-10">Por favor, carga un archivo de guardado (local o nube) para ver el mapa.</p>
            </div>
        </main>
    </div>

    <script>
        // --- CONSTANTES ---
        const TILE_SIZE_PX = 8; 
        const GAME_CHUNK_WIDTH = 60; 
        const GAME_CHUNK_HEIGHT = 60; 
        const GAME_TILE_WIDTH = 70; 
        const GAME_TILE_HEIGHT = 70; 

        const TERRAIN_COLORS = {
            "GRASS": "#22c55e",
            "STONE_GROUND": "#78716c",
            "DIRT": "#a16207",
            "WATER": "#0ea5e9",
            "WALL": "#4b5563",
            "DEFAULT": "#111827",
            "SAND": "#fde047", 
            "SAVANNA_GRASS": "#d97706", 
            "JUNGLE_GRASS": "#15803d", 
            "SNOW": "#f8fafc",
            // --- ¡NUEVO! ---
            "CAVE_FLOOR": "#57534e", // stone-600
            "ROCK_WALL": "#374151"  // gray-700
        };
        const ENTITY_COLORS = {
            "TREE": "#166534",
            "ROCK": "#57534e",
            "NPC": "#eab308",
            "STATUE": "#a8a29e",
            "ITEM": "#f97316",
            "DEFAULT": "#fefefe",
            "CACTUS": "#84cc16", 
            "ACACIA_TREE": "#a3e635", 
            "JUNGLE_TREE": "#16a34a", 
            "SNOW_TREE": "#dbeafe",
             // --- ¡NUEVO! ---
            "IRON_VEIN": "#e5e7eb", // gray-200
            "STAIRS_UP": "#f59e0b", // amber-500
            "STAIRS_DOWN": "#8b5cf6" // violet-500
        };
        const PLAYER_COLOR = "#ef4444"; 

        // --- CONSTANTES FIREBASE ---
        const CHUNKS_ROOT = 'chunks_v2';
        const PLAYER_STATES_ROOT = 'playerStates_v2';

        // --- ESTADO GLOBAL ---
        let saveData = null;
        let canvas = null;
        let ctx = null;
        let minChunkX = 0, maxChunkX = 0, minChunkY = 0, maxChunkY = 0;
        let minGlobalTileX = 0, minGlobalTileY = 0;
        let totalCanvasWidth = 0, totalCanvasHeight = 0;
        let selectedTile = null; 
        let currentZLevel = 0; // <-- ¡NUEVO!

        // --- ESTADO DE CÁMARA ---
        let zoom = 1.0;
        let offsetX = 0;
        let offsetY = 0;
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // --- ESTADO FIREBASE ---
        let dbInstance = null;

        // --- ELEMENTOS DEL DOM ---
        let fileInput, statsPanel, statsContent, legendContent, editorPanel;
        let selectedTileInfo, tileTypeSelect, downloadButton, mapContainer, loadingMessage;
        let mainContent;
        let firebaseConfigInput, firebaseProfileName, firebaseLoadBtn, firebaseMessagePanel;
        let zLevelDownBtn, zLevelUpBtn, zLevelInput; // <-- ¡NUEVO!


        /**
         * Inicializa la aplicación
         */
        function init() {
            // Cachear elementos del DOM
            canvas = document.getElementById('map-canvas');
            ctx = canvas.getContext('2d');
            fileInput = document.getElementById('file-input');
            statsPanel = document.getElementById('stats-panel');
            statsContent = document.getElementById('stats-content');
            legendContent = document.getElementById('legend-content');
            editorPanel = document.getElementById('editor-panel');
            selectedTileInfo = document.getElementById('selected-tile-info');
            tileTypeSelect = document.getElementById('tile-type-select');
            downloadButton = document.getElementById('download-button');
            mapContainer = document.getElementById('map-container');
            loadingMessage = document.getElementById('loading-message');
            mainContent = document.getElementById('main-content');
            
            firebaseConfigInput = document.getElementById('firebase-config-input');
            firebaseProfileName = document.getElementById('firebase-profile-name');
            firebaseLoadBtn = document.getElementById('firebase-load-btn');
            firebaseMessagePanel = document.getElementById('firebase-message-panel');

            // --- ¡NUEVO! Cachear Z-Level ---
            zLevelDownBtn = document.getElementById('z-level-down');
            zLevelUpBtn = document.getElementById('z-level-up');
            zLevelInput = document.getElementById('z-level-input');

            // Listeners
            fileInput.addEventListener('change', handleFileLoad);
            firebaseLoadBtn.addEventListener('click', handleFirebaseLoad); 
            
            // --- ¡NUEVO! Listeners Z-Level ---
            zLevelDownBtn.addEventListener('click', () => changeZLevel(-1));
            zLevelUpBtn.addEventListener('click', () => changeZLevel(1));
            zLevelInput.addEventListener('change', handleZLevelInput);
            
            // Listeners de Cámara
            canvas.addEventListener('wheel', handleWheelZoom, { passive: false });
            canvas.addEventListener('mousedown', handlePanStart);
            canvas.addEventListener('mousemove', handlePanMove);
            canvas.addEventListener('mouseup', handlePanEnd);
            canvas.addEventListener('mouseleave', handlePanEnd);
            canvas.addEventListener('click', handleCanvasClick);
            
            // Listeners de Editor
            tileTypeSelect.addEventListener('change', handleTileTypeChange);
            downloadButton.addEventListener('click', handleSave);

            window.addEventListener('resize', resizeViewerCanvas);
            resizeViewerCanvas(); 

            generateLegend();
            populateEditorSelect();
        }

        /**
         * Ajusta el tamaño del canvas al de su contenedor.
         */
        function resizeViewerCanvas() {
            canvas.width = mainContent.clientWidth;
            canvas.height = mainContent.clientHeight;
            draw(); 
        }

        // --- ¡NUEVAS FUNCIONES Z-LEVEL! ---
        function changeZLevel(delta) {
            currentZLevel += delta;
            zLevelInput.value = currentZLevel;
            calculateMapBounds(); // Recalcular límites para el nuevo Z
            centerMap();
            draw();
        }
        function handleZLevelInput() {
            currentZLevel = parseInt(zLevelInput.value, 10) || 0;
            zLevelInput.value = currentZLevel;
            calculateMapBounds();
            centerMap();
            draw();
        }

        // --- FUNCIONES FIREBASE (Sin cambios) ---
        function initFirebase(configString) {
            if (dbInstance) return true; 
            let config;
            try {
                config = (new Function("return " + configString))();
                if (typeof config !== 'object' || !config.apiKey || !config.databaseURL) {
                    throw new Error("Configuración no válida o incompleta.");
                }
            } catch (e) {
                firebaseMessagePanel.textContent = `Error de Config: ${e.message}`;
                return false;
            }
            try {
                if (!firebase.apps.length) {
                    firebase.initializeApp(config);
                }
                dbInstance = firebase.database();
                firebaseMessagePanel.textContent = "Conectado a Firebase.";
                return true;
            } catch (e) {
                firebaseMessagePanel.textContent = `Error de Firebase: ${e.message}`;
                dbInstance = null;
                return false;
            }
        }
        async function handleFirebaseLoad() {
            const configString = firebaseConfigInput.value;
            const profileName = firebaseProfileName.value.trim();
            if (!initFirebase(configString)) return;

            try {
                firebaseMessagePanel.textContent = "Cargando mapa (chunks)...";
                const chunksSnapshot = await dbInstance.ref(CHUNKS_ROOT).once('value');
                const loadedMapData = chunksSnapshot.val();

                if (!loadedMapData) {
                    throw new Error(`No se encontró mapa en '${CHUNKS_ROOT}'.`);
                }
                firebaseMessagePanel.textContent = "Mapa cargado. Buscando jugador...";

                let loadedPlayerState = null;
                if (profileName) {
                    const playerStateSnapshot = await dbInstance.ref(`${PLAYER_STATES_ROOT}/${profileName}`).once('value');
                    loadedPlayerState = playerStateSnapshot.val();
                    if (loadedPlayerState) {
                         firebaseMessagePanel.textContent = "¡Jugador encontrado!";
                    } else {
                         firebaseMessagePanel.textContent = "Jugador no encontrado, usando (0,0,0).";
                    }
                } else {
                    firebaseMessagePanel.textContent = "Sin perfil, usando (0,0,0).";
                }

                if (!loadedPlayerState) {
                    loadedPlayerState = {
                        x: 0, y: 0, z: 0,
                        stats: { vida: 0, vidamax: 0, energia: 0, energiamax: 0 }
                    };
                }

                const cloudSaveData = {
                    playerState: loadedPlayerState,
                    mapData: loadedMapData,
                    savedAt: new Date().toISOString()
                };
                
                processSaveData(cloudSaveData);

            } catch (err) {
                firebaseMessagePanel.textContent = `Error: ${err.message}`;
                console.error(err);
            }
        }


        // --- FUNCIONES DE CARGA REFACTORIZADAS ---

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            firebaseMessagePanel.textContent = "Cargando archivo local...";
            const reader = new FileReader();
            
            reader.onload = (e) => {
                try {
                    const localData = JSON.parse(e.target.result);
                    processSaveData(localData); 
                    firebaseMessagePanel.textContent = "Archivo local cargado.";
                } catch (err) {
                    loadingMessage.textContent = `Error: ${err.message}`;
                    loadingMessage.classList.remove('hidden');
                    firebaseMessagePanel.textContent = `Error: ${err.message}`;
                    console.error(err);
                }
            };
            reader.readAsText(file);
        }
        
        function processSaveData(data) {
            if (!data || !data.mapData) {
                const errorMsg = "Archivo de guardado inválido (falta 'mapData').";
                firebaseMessagePanel.textContent = errorMsg;
                loadingMessage.textContent = errorMsg;
                loadingMessage.classList.remove('hidden');
                throw new Error(errorMsg);
            }
            
            saveData = data; 
            
            // --- ¡MODIFICADO! Leer Z del jugador ---
            if(saveData.playerState) {
                renderStats();
                statsPanel.classList.remove('hidden');
                // ¡Actualizar el visor al Z del jugador!
                currentZLevel = saveData.playerState.z || 0;
                zLevelInput.value = currentZLevel;
            } else {
                statsPanel.classList.add('hidden'); 
                currentZLevel = 0;
                zLevelInput.value = 0;
            }

            loadingMessage.classList.add('hidden');

            calculateMapBounds(); // ¡Importante! Calcular para el Z actual
            centerMap();
            draw();
            
            editorPanel.classList.remove('hidden');
        }


        // --- ¡MODIFICADO! ---
        function renderStats() {
            if (!saveData || !saveData.playerState) return;
            // ¡Leer Z del playerState!
            const { stats, x, y, z } = saveData.playerState;
            statsContent.innerHTML = `
                <p><span class="font-semibold text-gray-400">Pos (X, Y, Z):</span> ${Math.round(x)}, ${Math.round(y)}, ${z || 0}</p>
                <p><span class="font-semibold text-red-400">Vida:</span> ${stats.vida} / ${stats.vidamax}</p>
                <p><span class="font-semibold text-green-400">Energía:</span> ${stats.energia} / ${stats.energiamax}</p>
            `;
            // Quitados stats antiguos (oro, madera, etc.)
        }

        function generateLegend() {
            let legendHTML = '';
            for (const key in TERRAIN_COLORS) {
                if (key === "DEFAULT") continue;
                legendHTML += `<div class="flex items-center"><div class="w-4 h-4 rounded-sm mr-2" style="background-color: ${TERRAIN_COLORS[key]}"></div><span>${key}</span></div>`;
            }
             for (const key in ENTITY_COLORS) {
                if (key === "DEFAULT") continue;
                legendHTML += `<div class="flex items-center"><div class="w-4 h-4 rounded-sm mr-2 border border-white" style="background-color: ${ENTITY_COLORS[key]}"></div><span>${key}</span></div>`;
            }
            legendHTML += `<div class="flex items-center"><div class="w-4 h-4 rounded-full mr-2" style="background-color: ${PLAYER_COLOR}"></div><span>PLAYER</span></div>`;
            legendContent.innerHTML = legendHTML;
        }

        function populateEditorSelect() {
             for (const key in TERRAIN_COLORS) {
                if (key === "DEFAULT") continue;
                const option = document.createElement('option');
                option.value = key;
                option.textContent = key;
                tileTypeSelect.appendChild(option);
            }
        }

        // --- ¡MODIFICADO! ---
        function calculateMapBounds() {
            if (!saveData) return;
            
            minChunkX = Infinity; maxChunkX = -Infinity;
            minChunkY = Infinity; maxChunkY = -Infinity;
            let chunksFoundOnThisLevel = 0;

            for (const key of Object.keys(saveData.mapData)) {
                const [x, y, z] = key.split(',').map(Number);
                
                // ¡Filtrar por Z!
                if (z !== currentZLevel) continue; 
                chunksFoundOnThisLevel++;

                if (x < minChunkX) minChunkX = x;
                if (x > maxChunkX) maxChunkX = x;
                if (y < minChunkY) minChunkY = y;
                if (y > maxChunkY) maxChunkY = y;
            }

            if (chunksFoundOnThisLevel === 0) {
                totalCanvasWidth = 0;
                totalCanvasHeight = 0;
                minGlobalTileX = 0;
                minGlobalTileY = 0;
                return;
            }

            const totalChunksX = maxChunkX - minChunkX + 1;
            const totalChunksY = maxChunkY - minChunkY + 1;
            
            totalCanvasWidth = totalChunksX * GAME_CHUNK_WIDTH * TILE_SIZE_PX;
            totalCanvasHeight = totalChunksY * GAME_CHUNK_HEIGHT * TILE_SIZE_PX;

            minGlobalTileX = minChunkX * GAME_CHUNK_WIDTH;
            minGlobalTileY = minChunkY * GAME_CHUNK_HEIGHT;
        }

        function centerMap() {
            if (!saveData || totalCanvasWidth === 0 || totalCanvasHeight === 0) {
                // Si no hay chunks, solo centrar
                zoom = 1.0;
                offsetX = canvas.width / 2;
                offsetY = canvas.height / 2;
                return;
            };
            const zoomX = canvas.width / totalCanvasWidth;
            const zoomY = canvas.height / totalCanvasHeight;
            zoom = Math.min(zoomX, zoomY) * 0.9; 
            offsetX = (canvas.width - (totalCanvasWidth * zoom)) / 2;
            offsetY = (canvas.height - (totalCanvasHeight * zoom)) / 2;
        }


        function draw() {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(zoom, zoom);

            if (saveData) {
                drawMapData();
                drawPlayer(); 
            }
            ctx.restore();
        }

        // --- ¡MODIFICADO! ---
        function drawMapData() {
            // 1. Dibujar Terreno
            for (const chunkKey in saveData.mapData) {
                const [chunkX, chunkY, chunkZ] = chunkKey.split(',').map(Number);
                
                // ¡Filtrar por Z!
                if (chunkZ !== currentZLevel) continue;

                const chunk = saveData.mapData[chunkKey];
                if (!chunk || !chunk.terrain) continue; 
                
                const canvasOffsetX = (chunkX - minChunkX) * GAME_CHUNK_WIDTH * TILE_SIZE_PX;
                const canvasOffsetY = (chunkY - minChunkY) * GAME_CHUNK_HEIGHT * TILE_SIZE_PX;

                for (let y = 0; y < GAME_CHUNK_HEIGHT; y++) {
                    for (let x = 0; x < GAME_CHUNK_WIDTH; x++) {
                        const tileKey = (chunk.terrain[y] && chunk.terrain[y][x]) ? chunk.terrain[y][x] : "DEFAULT";
                        ctx.fillStyle = TERRAIN_COLORS[tileKey] || TERRAIN_COLORS.DEFAULT;
                        ctx.fillRect(
                            canvasOffsetX + (x * TILE_SIZE_PX),
                            canvasOffsetY + (y * TILE_SIZE_PX),
                            TILE_SIZE_PX,
                            TILE_SIZE_PX
                        );
                    }
                }
            }

            // 2. Dibujar Entidades
            for (const chunkKey in saveData.mapData) {
                const [chunkX, chunkY, chunkZ] = chunkKey.split(',').map(Number);
                
                // ¡Filtrar por Z!
                if (chunkZ !== currentZLevel) continue;

                const chunk = saveData.mapData[chunkKey];
                if (!chunk || !chunk.entities) continue; 
                
                const canvasOffsetX = (chunkX - minChunkX) * GAME_CHUNK_WIDTH * TILE_SIZE_PX;
                const canvasOffsetY = (chunkY - minChunkY) * GAME_CHUNK_HEIGHT * TILE_SIZE_PX;

                const chunkPixelX = chunkX * GAME_CHUNK_WIDTH * GAME_TILE_WIDTH;
                const chunkPixelY = chunkY * GAME_CHUNK_HEIGHT * GAME_TILE_HEIGHT;

                for (const entity of chunk.entities) {
                    // ¡Filtrar entidades por Z!
                    // (Aunque el chunk ya está filtrado, es una doble seguridad si 'z' está en la entidad)
                    if (entity.z !== currentZLevel) continue;

                    const localPixelX = entity.x - chunkPixelX;
                    const localPixelY = entity.y - chunkPixelY;
                    
                    const localTileX = Math.floor(localPixelX / GAME_TILE_WIDTH);
                    const localTileY = Math.floor(localPixelY / GAME_TILE_HEIGHT);

                    const canvasX = canvasOffsetX + (localTileX * TILE_SIZE_PX);
                    const canvasY = canvasOffsetY + (localTileY * TILE_SIZE_PX);

                    ctx.fillStyle = ENTITY_COLORS[entity.key] || ENTITY_COLORS.DEFAULT;
                    ctx.fillRect(
                        canvasX + TILE_SIZE_PX * 0.2, 
                        canvasY + TILE_SIZE_PX * 0.2,
                        TILE_SIZE_PX * 0.6,
                        TILE_SIZE_PX * 0.6
                    );
                }
            }
        }

        // --- ¡MODIFICADO! ---
        function drawPlayer() {
            if (!saveData || !saveData.playerState) return; 
            
            // ¡No dibujar al jugador si no está en este Z-level!
            if (saveData.playerState.z !== currentZLevel) return;
            
            const playerX = saveData.playerState.x;
            const playerY = saveData.playerState.y;

            const globalPlayerTileX = Math.floor(playerX / GAME_TILE_WIDTH);
            const globalPlayerTileY = Math.floor(playerY / GAME_TILE_HEIGHT);

            const playerCanvasTileX = globalPlayerTileX - minGlobalTileX;
            const playerCanvasTileY = globalPlayerTileY - minGlobalTileY;

            ctx.fillStyle = PLAYER_COLOR;
            ctx.beginPath();
            ctx.arc(
                (playerCanvasTileX * TILE_SIZE_PX) + TILE_SIZE_PX / 2,
                (playerCanvasTileY * TILE_SIZE_PX) + TILE_SIZE_PX / 2,
                TILE_SIZE_PX / 1.5, 
                0, 2 * Math.PI
            );
            ctx.fill();
        }


        // --- FUNCIONES DE CÁMARA (Sin cambios) ---
        function handleWheelZoom(event) {
            event.preventDefault();
            if (!saveData) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const worldX = (mouseX - offsetX) / zoom;
            const worldY = (mouseY - offsetY) / zoom;
            const zoomFactor = 1.1;
            const newZoom = event.deltaY < 0 ? zoom * zoomFactor : zoom / zoomFactor;
            zoom = Math.max(0.05, Math.min(newZoom, 50)); 
            offsetX = mouseX - worldX * zoom;
            offsetY = mouseY - worldY * zoom;
            draw();
        }
        function handlePanStart(event) {
            if (event.button !== 0) return; 
            isPanning = true;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
            canvas.style.cursor = 'grabbing';
        }
        function handlePanMove(event) {
            if (!isPanning) return;
            const dx = event.clientX - lastMouseX;
            const dy = event.clientY - lastMouseY;
            offsetX += dx;
            offsetY += dy;
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;
            draw();
        }
        function handlePanEnd() {
            isPanning = false;
            canvas.style.cursor = 'grab';
        }

        // --- FUNCIONES DE EDICIÓN (MODIFICADAS) ---

        function handleCanvasClick(event) {
            if (!saveData || isPanning) return; 
            
            const dx = event.clientX - lastMouseX;
            const dy = event.clientY - lastMouseY;
            if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
                lastMouseX = event.clientX;
                lastMouseY = event.clientY;
                return;
            }
            lastMouseX = event.clientX;
            lastMouseY = event.clientY;

            const rect = canvas.getBoundingClientRect();
            const canvasX = event.clientX - rect.left;
            const canvasY = event.clientY - rect.top;

            const worldX = (canvasX - offsetX) / zoom;
            const worldY = (canvasY - offsetY) / zoom;
            
            const clickedCanvasTileX = Math.floor(worldX / TILE_SIZE_PX);
            const clickedCanvasTileY = Math.floor(worldY / TILE_SIZE_PX);

            const globalTileX = minGlobalTileX + clickedCanvasTileX;
            const globalTileY = minGlobalTileY + clickedCanvasTileY;

            const chunkX = Math.floor(globalTileX / GAME_CHUNK_WIDTH);
            const chunkY = Math.floor(globalTileY / GAME_CHUNK_HEIGHT);
            const chunkKey = `${chunkX},${chunkY},${currentZLevel}`; // <-- ¡USAR Z!

            const localX = ((globalTileX % GAME_CHUNK_WIDTH) + GAME_CHUNK_WIDTH) % GAME_CHUNK_WIDTH;
            const localY = ((globalTileY % GAME_CHUNK_HEIGHT) + GAME_CHUNK_HEIGHT) % GAME_CHUNK_HEIGHT;

            const chunk = saveData.mapData[chunkKey];
            if (!chunk || !chunk.terrain[localY]) { 
                selectedTileInfo.textContent = "Tile fuera de los límites (no guardado).";
                selectedTile = null;
                return;
            }

            const tileKey = chunk.terrain[localY][localX];
            
            selectedTileInfo.textContent = `Coords: (${globalTileX}, ${globalTileY}, ${currentZLevel}) - Tipo: ${tileKey}`;
            tileTypeSelect.value = tileKey;
            
            selectedTile = { chunkKey, localX, localY, globalTileX, globalTileY }; 
        }

        function handleTileTypeChange(event) {
            if (!selectedTile || !saveData) return;

            const newTileKey = event.target.value;
            const { chunkKey, localX, localY, globalTileX, globalTileY } = selectedTile;

            saveData.mapData[chunkKey].terrain[localY][localX] = newTileKey;
            selectedTileInfo.textContent = `Coords: (${globalTileX}, ${globalTileY}, ${currentZLevel}) - Tipo: ${newTileKey}`;
            draw();
        }

        function handleSave() {
            if (!saveData) return;
            
            saveData.savedAt = new Date().toISOString();
            const jsonData = JSON.stringify(saveData);
            downloadJSON(jsonData, 'partida_editada_3D.json');
        }

        function downloadJSON(content, fileName) {
            const a = document.createElement('a');
            const file = new Blob([content], { type: 'application/json' });
            a.href = URL.createObjectURL(file);
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>